var relearn_search_index = [
  {
    "content": "Cette page liste dans l’ordre chronologique les différentes dates limites de soumission à des conférences. Pour les conférences disposant de plusieurs sessions, chaque date est reportée. Sont uniquement considérées les conférences en lien avec les thématiques suivantes:\n Sécurité, Architecture des ordinateurs, Microarchitecture.  Elles sont également classées par couleur selon leur importance:\n  Rang A*   Rang A   Rang B   Nationale   Autres   Dernière mise à jour: 2023-04-20\n  Acronyme Rang Soumission Date Sujets d'intérêts   HiPEAC B Continue 2024-01-17   Architecture des processeurs Simulation et modélisation    ESORICS A 2023-01-22 2023-09-25   Sécurité matérielle Sécurité des systèmes    CHES A 2023-01-15 2023-09-10   Implémentations cryptographiques Sécurité matérielle Canaux auxiliaires Sécurité RISC-V    HOST B 2023-01-16 2023-05-01   Sécurité matérielle Architectures sécurisées Sécurité des systèmes    SAFECOMP B 2023-02-06 2023-09-19   Sécurité matérielle Modélisation et simulation    USENIX Security A* 2024-02-08 2024-08-14   Sécurité des systèmes Sécurité matérielle Applications cryptographiques    WOOT  2023-02-10 2023-05-25   Attaques matérielles IoT    ASAP A 2023-02-20 2023-07-19   FPGA Systèmes embarqués Sécurité Applications cryptographiques    ARES B 2023-03-09 2023-08-29   Canaux auxiliaires Sécurité IoT Modélisation des attaques    SECRYPT B 2023-03-15 2023-07-10   Sécurité IoT Applications cryptographiques    CASES B 2023-03-16 2023-09-17   Processeurs Systèmes embarqués Sécurité    PACT B 2023-03-25 2023-10-21   Architectures parallèles    ICICS B 2023-03-30 2023-11-18   Applications cryptographiques Sécurité matérielle Canaux auxiliaires    SAMOS B 2023-03-31 2023-07-02   Architectures multicoeurs Co-conception logiciel/matériel    CARRV  2023-04-03 2023-06-17   ISA RISC-V Sécurité RISC-V Interface logiciel/matériel    COMPAS National 2023-04-07 2023-07-04   Parallélisme Architecture Systèmes    ARCS B 2023-04-07 2023-06-13   Microarchitectures Sécurité    S\u0026P A* 2023-04-13 2024-05-20   Sécurité matérielle Sécurité des systèmes embarqués Sécurité des systèmes d'exploitation    CHES A 2023-04-15 2023-09-10   Implémentations cryptographiques Sécurité matérielle Canaux auxiliaires Sécurité RISC-V    MICRO A* 2023-04-21 2023-10-28   Microarchitecture IoT et systèmes embarqués Architectures pour la sécurité    DSD B 2023-04-30 2023-09-06   Conception matérielle Systèmes embarqués Systèmes sécurisés    WCAE  2023-05-01 2023-06-17   Enseignements Travaux pratiques Plateformes    OSCAR  2023-05-05 2023-06-18   Processeurs libres et ouverts Sécurité des architectures Simulation des architectures    MASCOTS B 2023-05-19 2023-10-16   Modélisation et simulation Architectures des processeurs IoT Sécurité    ESORICS A 2023-05-28 2023-09-25   Sécurité matérielle Sécurité des systèmes    USENIX Security A* 2023-06-06 2024-08-14   Sécurité des systèmes Sécurité matérielle Applications cryptographiques    ICECS B 2023-06-16 2023-12-04   Conception matérielle Systèmes embarqués    CARDIS B 2022-06-24 2022-11-07   Sécurité: IoT, systèmes embarqués ... Implémentations cryptographiques Canaux auxiliaires Outils: détection, analyse ...    CHES A 2022-07-15 2023-09-10   Implémentations cryptographiques Sécurité matérielle Canaux auxiliaires Sécurité RISC-V    HPCA A* 2023-07-25 2023-02-25   Processeurs et microarchitectures Systèmes embarqués FPGA Sécurité    NordSec C 2023-08-01 2023-11-16   Applications cryptographiques Sécurité matérielle    S\u0026P A* 2023-08-03 2024-05-20   Sécurité matérielle Sécurité des systèmes embarqués Sécurité des systèmes d'exploitation    ASIACCS A 2023-08-21 2024-07-01   Sécurité des systèmes    ACNS B 2022-09-08 2023-06-19   Applications cryptographiques Canaux auxiliaires    HASP  2022-09-09 2022-10-01   Processeurs sécurisés Mémoires caches sécurisées Canaux auxiliaires Implémentations cryptographiques    DATE B 2023-09-18 2023-04-17   Conception de systèmes sécurisés Conception d'architectures et microarchitectures Modélisation et simulation    CHES A 2022-10-15 2023-09-10   Implémentations cryptographiques Sécurité matérielle Canaux auxiliaires Sécurité RISC-V    HOST B 2022-10-17 2023-05-01   Sécurité matérielle Architectures sécurisées Sécurité des systèmes    USENIX Security A* 2023-10-17 2024-08-14   Sécurité des systèmes Sécurité matérielle Applications cryptographiques    EuroS\u0026P A* 2022-10-26 2023-07-03   Sécurité matérielle Sécurité des systèmes embarqués Sécurité des systèmes d'exploitation    ISCA A* 2022-11-21 2023-06-17   Architectures des processeurs Architectures pour la sécurité IoT et systèmes embarqués Modélisation et simulation    COSADE B 2022-11-28 2023-04-03   Sécurité matérielle Canaux auxiliaires    S\u0026P A* 2023-12-06 2024-05-20   Sécurité matérielle Sécurité des systèmes embarqués Sécurité des systèmes d'exploitation    ASIACCS A 2023-12-07 2024-07-01   Sécurité des systèmes      2023- 2023-         ",
    "description": "",
    "tags": null,
    "title": "Chronologie des conférences",
    "uri": "/more/hidden/conferences/index.html"
  },
  {
    "content": "Informations globales Langage de description matérielle (HDL) Les langages de description matérielle sont utilisés pour décrire le fonctionnement des circuits électroniques numériques. Pour la conception des différents composants matériels, HerdWare se base principalement sur le langage Chisel3.\nChisel3 est un langage libre et ouvert initialement développé à l’Université de Berkeley et basé sur le langage Scala. Il permet la description du fonctionnement de circuits numériques, mais aussi intègre des fonctionnalités pour la génération matérielle. Le Chisel3 peut être compilé afin de générer du Verilog synthétisable. Étant basé sur le langage Scala, le Chisel3 supporte également des fonctionnalités de langage haut-niveau (programmation orientée objet, héritage etc.).\nDans HerdWare, la plupart des composants matériels (processeurs, périphériques etc.) sont conçus en utilisant du Chisel3. Ils sont principalement organisés en de nombreux modules réutilisables. Comme décrit dans les prochaines pages, des objets sont ensuite instanciés dans le code pour permettre la génération du Verilog de chaque composant. Finalement, les différents composants Verilog générés sont parfaitement compatibles avec les outils de conceptions standards (Vivado, Verilator et tous ceux supportant le Verilog).\nOrganisation  HerdWare: Cette partie donne des informations globales sur le projet. Différentes pages sont disponibles pour l’installation des outils, la simulation des composants matériels et leur configuration. Documentation: Cette partie décrit les différents développements du projet: matériel, logiciel mais aussi des modifications du jeu d’instructions. Le code de la plupart d’entre eux est directement disponible sur GitHub. Références: Cette page liste les différetes références (articles, sites) utilisées sur le site. Glossaire: Cette page liste les différents acronymes et termes techniques utilisés sur le site.  ",
    "description": "",
    "tags": null,
    "title": "Description",
    "uri": "/all/description/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "HerdWare",
    "uri": "/all/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Architecture de jeu d'instructions (ISA)",
    "uri": "/doc/isa/index.html"
  },
  {
    "content": "  Origine du nom Source de l'image.  Aubrac est le nom d’une race française de vaches originaire du Plateau de l’Aubrac dans le centre de la France. Elle est notamment élevée pour son lait utilisé pour le fromage Laguiole.\n  Cette page et les suivantes décrivent le processeur Aubrac. Il permet l’exécution dans l’ordre d’une instruction par cycle. Il est conçu autour d’un pipeline et de deux niveaux de mémoires caches. Basé sur l’ISA RISC-V, il est développé en Chisel3 et se veut hautement configurable (taille des données, nombre d’étages, extensions du jeu d’instructions supportées etc.).\nVue globale   \nFigure 1: Vue globale du processeur Aubrac.  Tous les différents étages possibles sont représentés, même si certains d'entre eux sont optionnels.    La Figure 1 représente le processeur Aubrac entier. Celui-ci est composé de 8 parties. Le Front-End est responsable de la récupération des instructions en mémoire. Le NLP est responsable de la prédiction des aléas du flot de contrôle. Le Back-End est responsable du décodage et de l’exécution des instructions. L’unité de gestion des champs matériels (HFU) est une unité d’exécution dédiée à la contextualisation (CHAMP ISA). Le module des I/O est utilisé pour les mécanismes addressables en mémoire spécifiques au processeur (e.g. les timers privilégiés). Enfin, L1I, L1D et L2 sont respectivement le cache d’instruction de niveau 1, le cache de données de niveau 1 et le cache unifié de niveau 2.\nSupport du jeu d’instructions Le processeur Aubrac est basé sur l’ISA RISC-V. Il supporte actuellement les bases 32 et 64 bits du jeu d’instructions.\n   Extension Version Implementée ? Testée ? Optionnelle ? Dépendances     M 2.0       A 2.1       B 1.0.0       Zicsr        Zicntr        Zifencei 2.0        Tableau 1: Résumé des différentes extensions RISC-V supportées par le processeur Aubrac.  Certaines doivent encore être testées plus en profondeur.    Comme décrit dans la Tableau 1, de multiples extensions sont actuellemnt implémentées dans Aubrac. La plupart d’entre elles sont optionnelles: les différents mécanismes matériels dédiés peuvent être totalement supprimés lors de la génération du Verilog.\n Avertissement Si les versions 32 et 64 bits sont implémentées, seule la version 32 bits est actuellement utilisée et testée. Un travail supplémentaire est nécessaire pour vérifier les instructions spécifiques à la version 64 bits, comme celles dédiées à la manipulation de mots de 32 bits.\n  Sommaire Front-end Étage PC Étages IF{0-2} Étage IF3 Paramètres Prédiction de branchement Prédicteur de prochaine ligne (NLP) Back-end Étage ID Étage EX{0-2} Étage MEM Étage WB Registres généraux (GPR) Registres de Contrôle et de Statut (CSR) Hiérarchie mémoire Mémoires caches Interruptions locales du processeur (CLINT) Timers privilégiés Moniteur des performances matérielles (HPM) Top Pipeline Processeur Paramètres  ",
    "description": "",
    "tags": null,
    "title": "Aubrac",
    "uri": "/doc/hw/cores/aubrac/index.html"
  },
  {
    "content": "  Astuce    Figure 1: Vue globale de la plateforme Cheese.     ",
    "description": "",
    "tags": null,
    "title": "Cheese",
    "uri": "/doc/hw/pltf/cheese/index.html"
  },
  {
    "content": "Sommaire Étage PC  Étages IF{0-2}  Étage IF3  Paramètres   Vue globale Le Front-End est la partie matérielle responsable de récupérer les instructions en mémoire. Directement associé au NLP pour la prédiction de branchement, il calcule chaque cycle la valeur du compteur ordinal (PC pour program counter en anglais). Ensuite, il l’utilise pour charger les instructions correspondantes depuis la mémoire.\n Figure 1: Vue globale du Front-End.     La version actuelle du Front-End est composée de cinq étages configurables:\n L’étage PC calcule l’adresse de la prochaine instruction à charger en mémoire. Les étages IF{0-2} gèrent l’interface mémoire pour la récupération des instructions. L’étage IF3 est utilisé pour le pré-décodage avant d’envoyer les instructions dans le fetch buffer.  L’ensemble du code est disponible dans un répertoire du projet Aubrac sur GitHub.\n",
    "description": "",
    "tags": null,
    "title": "Front-end",
    "uri": "/doc/hw/cores/aubrac/front/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "GPIO",
    "uri": "/doc/hw/io/gpio/index.html"
  },
  {
    "content": "Biographie Je suis actuellement post-doctorant en sécurité informatique au LAAS-CNRS de Toulouse en France. Je travaille au côté de Vincent Migliore sur la conception de processeurs sécurisés contre les attaques par canaux auxiliaires (consommation d'énergie et émissions électromagnétiques).  Précédemment, j'ai obtenu un diplôme d'ingénieur par apprentissage en électronique et microélectronique à PHELMA - Grenoble INP. Ensuite, durant mon doctorat, j'ai travaillé dans l'équipe CIDRE de l'Inria à Rennes, supervisé par Ronan Lashermes.  Mathieu Escouteloup       Sujets d'intérêts  Architecture des processeurs Conception de circuits numériques Sécurité matérielle Interface logiciel/matériel Attaques par canaux auxiliaires  Expériences professionnelles  2021/11 - Aujourd'hui: Post-doctorant LAAS-CNRS, Toulouse, France  2018/10 - 2021/09: Doctorant Inria, Rennes, France  2015/09 - 2018/08: Apprenti ingénieur Dolphin Integration (devenu Dolphin Design), Meylan, France    Parcours scolaire  Doctorat en informatique, 2021 Garantir l'isolation microarchitecturale des processeurs Université de Rennes 1, France  École d'ingénieurs, 2018 PHELMA - Grenoble INP, France  DUT Mesures Physiques, 2015 IUT Paul Sabatier, Toulouse, France    Enseignements Aussi bien durant ma thèse que durant mon post-doctorat, j'ai pu assurer des vacations dans les cours suivant:    Cours Institution Année Niveau    Conception numérique - VHDL Université de Rennes 1 2019-2021 Master 1   Langage d'assemblage - Arm INSA Toulouse 2021-2023 Licence 3   Programmation Orientée Objet- C++ INSA Toulouse 2021-2022 Licence 3   Architecture des ordinateurs INSA Toulouse 2022-2023 Licence 2   Microcontrôleurs - C INSA Toulouse 2022-2023 Master 1   Publications 2021  Garantir l'isolation microarchitecturale des processeurs Mathieu Escouteloup Manuscrit de thèse Theses.fr Diapos   Under the dome: preventing hardware timing leakages Mathieu Escouteloup, Ronan Lashermes, Jacques Fournier et Jean-Louis Lanet International Conference on Smart Card Research and Advanced Applications (CARDIS 2021) HAL Conference Diapos   Electromagnetic Fault Injection against a Complex CPU, toward New Micro-Architectural Fault Models Thomas Trouchkine, Sébanjila Kevin Bukasa, Mathieu Escouteloup, Ronan Lashermes et Guillaume Bouffard Journal of Cryptographic Engineering (JCEN 2021) HAL   2020  Recommendations for a Radically Secure ISA Mathieu Escouteloup, Jacques Fournier, Jean-Louis Lanet and Ronan Lashermes Fourth Workshop on Computer Architecture Research with RISC-V (CARRV 2020) HAL Workshop Diapos   Talks 2021  Preventing timing information leakages from the microarchitecture Mathieu Escouteloup, Ronan Lashermes, Christophe Bidan and Jacques FournierS 2nd RISC-V Week Workshop Diapos   2019  Microarchitecture security Mathieu Escouteloup, Ronan Lashermes, Jean-Louis Lanet and Jacques Fournier Workshop on Practical Hardware Innovation in Security and Characterization (PHISIC 2019) Workshop Diapos   Projects  IDROMEL - Conception de systèmes sécurisés par une réduction des effets de la  micro-architecture sur les attaques par canaux auxiliaires  ANR   ",
    "description": "",
    "tags": null,
    "title": "Mathieu Escouteloup",
    "uri": "/more/about/mathieu-escouteloup/index.html"
  },
  {
    "content": "Résumé MB4S (Memory Bus for Security) est le nom d’un protocole utilisé dans le projet HerdWare pour les bus mémoires. De base, le fonctionnement et les signaux utilisés étaient similaires à ceux d’un bus Wishbone standard: deux interfaces ready / valid (fonctionnement en poignée de main ou handshake en anglais) pour les signaux de contrôle et pour les signaux de données. Suite à différents travaux de recherche, le protocole a été modifié pour intégrer de nouvelles fonctionnalités, comme le supporte de contraintes de sécurité.\nSommaire Protocole   ",
    "description": "",
    "tags": null,
    "title": "Memory Bus for Security (MB4S)",
    "uri": "/doc/hw/common/mb4s/index.html"
  },
  {
    "content": "Sommaire Memory Bus for Security (MB4S) Protocole  Résumé Le projet common définit des éléments matériels de base et communs à d’autres projets. Il se sépare en différentes catégories:\n bus: structures de certains bus et signaux communs, core: bus, signaux et modules utilisés par plusieurs implémentations de processeurs, field: bus, signaux, modules et paramètres de configuration pour la mise en place des champs matériels, gen: bus, signaux, modules et paramètres de configuration pour la mise en place de structures génériques (registres, FIFO etc.), isa: bus, signaux et modules utilisés pour les jeux d’instructions, mem: bus, signaux et modules utilisés pour les implémentations de mémoire, tools: divers modules et fonctions.  ",
    "description": "",
    "tags": null,
    "title": "Modules et interfaces communs",
    "uri": "/doc/hw/common/index.html"
  },
  {
    "content": "  Astuce   ",
    "description": "",
    "tags": null,
    "title": "Mémoire cache Hay",
    "uri": "/doc/hw/mem/hay/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Mémoires caches",
    "uri": "/doc/hw/cores/aubrac/mem-hier/caches/index.html"
  },
  {
    "content": "Vue globale   \nFigure 1: Vue globale du pipeline implémenté dans Aubrac.  Tous les différents étages possibles sont représentés, même si certains d'entre eux sont optionnels.    ",
    "description": "",
    "tags": null,
    "title": "Pipeline",
    "uri": "/doc/hw/cores/aubrac/top/pipeline/index.html"
  },
  {
    "content": "Principes de base  Figure 1: Protococole MB4S de base  Les préfixes i_* et o_* indiquent le sens des signaux (respectivement in et out) depuis le contrôleur maître.    Champ matériel Opération mémoire atomique (AMO) Version complète    Nom Optionnel Taille (en bits) Sens Description     req.ready  1 IN Prêt à recevoir (requête).   req.valid  1 OUT Prêt à envoyer (requête).   req.field  X OUT Champ matériel associé (requête)   req.ctrl.hart  X OUT Numéro du hart.   req.ctrl.op  1-3 OUT Type d’opération.   req.ctrl.amo  4 OUT Type d’opération atomique.   req.ctrl.size  3 OUT Taille de la donnée.   req.ctrl.addr  X OUT Adresse mémoire.   write.ready  1 IN Prêt à recevoir (écriture).   write.valid  1 OUT Prêt à envoyer (écriture).   write.field  X OUT Champ matériel associé (écriture)   write.data  X OUT Donnée (écriture).   read.ready  1 OUT Prêt à recevoir (lecture).   read.valid  1 IN Prêt à envoyer (lecture).   read.field  X IN Champ matériel associé (lecture)   read.data  X IN Donnée (lecture).    ",
    "description": "",
    "tags": null,
    "title": "Protocole",
    "uri": "/doc/hw/common/mb4s/protocol/index.html"
  },
  {
    "content": "Vue globale  Figure 1: Vue globale du NLP.  À chaque cycle, le Front-End damande au NLP les informations sur le prochain PC. Si celui-ci correspond à des informations internes comme un saut ou un branchement pris, alors le NLP spécule sur le PC suivant.    objectif: simple implémentation, réponse dans le cycle\nL’ensemble du code est disponible dans un répertoire du projet Aubrac sur GitHub.\nComposants internes En interne, le NLP est basé sur plusieurs composants. Chacun d’entre eux est spécifique à un type d’aléa: les sauts, les branchements conditionnels ou les appels de fonction.\nBranch Target buffer (BTB)  Figure 1: Fonctionnement du BTB  Quand un saut ou un branchement est détecté, ses informations sont enregistrées dans le BTB. Plus tard, avant de récupérer l'instruction correspondant à un PC, le BTB est lu pour anticiper des changements du flot d'exécution.    Pour chaque saut ou branchement, le BTB enregistre plusieurs informations:\n l’information est-elle valide ? l’adresse de l’instruction. l’adresse de destination. l’instruction est-elle un saut ? l’instruction est-elle un appel de fonction ? l’instruction est-elle un retour de fonction ?  Branch History Table (BHT)  Figure 2: Principe de la machine d'états finis du BHT  Chaque nouveau branchement met à jour un compteur qui indique si les derniers branchements croisés étaient majoritairement pris ou non.     Figure 3: Description du fonctionnement du BHT  Les bits de poids faible de l'adresse de chaque branchement pointe vers un compteur particulier. Selon la valeur du bit de poids fort du compteur, le BHT peut ensuite indiquer si le branchement doit être pris ou non.    Return Stack Buffer (RSB)  Figure 4: Description du fonctionnement d'un BHT.  Quand un appel est détecté, le PC de l'instruction suivante (basiquement PC+4) est sauvegardé au sommet du RSB, et le pointeur de pile est incrémenté. Quand un retour est détecté, la dernière valeur sauvegardée dans le RSB est récupérée et le pointeur de pile décrémenté.    Mise à jour des informations ",
    "description": "",
    "tags": null,
    "title": "Prédicteur de prochaine ligne (NLP)",
    "uri": "/doc/hw/cores/aubrac/pred/nlp/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Top",
    "uri": "/doc/hw/pltf/cheese/top/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Étage ID",
    "uri": "/doc/hw/cores/aubrac/back/id/index.html"
  },
  {
    "content": "Fonctionnement Chaque cycle, l’étage PC est responsable de calculer l’adresse de la prochaine instruction qui sera récupérée en mémoire (PC). Pour cela, un regstre interne à l’étage est incrémenté cycle par cycle pour parcourir les instructions les unes à la suite des autres.\nCependant, l’ISA RISC-V intègre des instructions de gestion du flot de contrôle comme des saut (jal et jalr) ou branchements conditionnels (beq, bne, bge, bgeu, blt et bltu). Ces instructions entraînent une non-linéarité des programmes. Ainsi, pour tenter de récupérer les bonnes instructions à chaque cycle, un prédicteur de branchement est nécessaire pour tenter de les anticiper. L’étage PC est pour cela connecté au NLP.\nCependant, il arrive que certaines prédictions ne soient pas correctes. De plus, certaines instructions ne sont parfois pas prédictibles. Différentes unités du processeur peuvent alors demander à l’étage PC de rediriger le flot d’exécution:\n L’unité BRU en cas de mauvaise prédiction d’un branchement ou d’un saut, L’unité HFU en cas de changement de champ matériel (voir CHAMP ISA), L’étage IF3 en cas de pré-décodage pour l’anticipation des sauts directs (jal).  ",
    "description": "",
    "tags": null,
    "title": "Étage PC",
    "uri": "/doc/hw/cores/aubrac/front/pc/index.html"
  },
  {
    "content": "Sommaire  Sommaire Pré-requis  sbt Verilator GTKWave Vivado Chaîne de compilation RISC-V   Installation locale  Pré-requis HerdWare utilise plusieurs outils pour générer, simuler et implémenter les différents composants matériels et logiciels. La plupart d’entre eux sont cependant gratuits, libres et ouverts.\n   Outils Version Matériel Logiciel Simulation FPGA     sbt        Verilator v4.216       GtkWave        Vivado 2021.2       RISC-V Toolchain         Tableau 1: Récapitulatif des différents outils nécessaires pour chaque tâche.     sbt Sbt est un outil libre et ouvert utilisé pour intéragir avec les différents projets développés en Scala. HerdWare utilise principalement le langage Chisel3 pour la conception matérielle. Le Chisel3 étant est basé sur le Scala, sbt est donc parfaitement adapté. Aisni, dans la plupart des exemples de commandes présentés ici, sbt est utilisé.\nPour installer sbt, le plus simple est de suivre les instructions d’installation correspondant à votre système d’exploitation.\nVerilator Verilator est un outil libre et ouvert permettant la génération de code SystemC à d’une description en Verilog/SystemVerilog. Une fois compilé, le code généré permet la création d’un exécutable pour simuler le système. Notamment, ce mode de simulation à l’avantage d’être particulièrement rapide par rapport aux autres simulateurs EDA. Dans ce projet, Verilator est utilisé pour générer des exécutables de chaque plateforme matérielle pour la simulation et l’exécution de logiciels.\nPour installer Verilator sur votre système, suivez les instructions sur le site officiel.\n Avertissement Il est recommandé d’installer une version stable en utilisant git (Git Quick Install). Actuellement, HerdWare a été testé avec succès en utilisant la version v4.216.\n  GTKWave GTKWave est un outil libre et ouvert pour la visualisation de chronogrammes. Il est particulièrement utile pour le debuggage afin de suivre l’origine d’un problème potentiel. Certianes fonctionnalités permettent le renommage de signal ou la création de groupe pour faciliter l’analyse. Dans HerdWare, GtkWave est particulièrement utilisé pour l’affichage des différents fichiers .vcd générés.\nLa méthode la plus simple pour installer GtkWave est de suivre les instructions suivantes: Ubuntu 20.04  sudo apt-get install gtkwave    \nVivado Vivado est le nom du logiciel de Xilinx pour la conception sur ses FPGAs. Ce logiciel est propriétaire mais son utilisation pour plusieurs cartes de développement très répandues est possible avec la version gratuite. Actuellement, HerdWare s’appuye sur cet outil pour l’implémentation sur les FPGAs Xilinx.\nLa meilleure méthode pour installer Vivado est de télécharger l’utilitaire disponible sur la page de téléchargement.\n Remarque La plupart des implémentations de ce projet ont été effectués avec la version 2021.2. Cependant, rien ne semble restreindre l’utilisation d’une version plus récente. En cas de problème, n’hésitez pas à le signaler.\n  Ubuntu 20.04  La première étape est de télécharger l’utilitaire Xilinx Unified Installer 2021.2: Linux Self Extracting Web Installer. Ensuite, il faut prévoir un répertoire sur votre système où seront installés les outils Xilinx. Gardez à l’esprit que les versions récentes de Vivado nécessitent un volume de stockage important (plusieurs dizaines de GB). Finalement, dans un terminal, placez-vous dans le répertoire où l’utilitaire a été téléchargé et exécutez:\nchmod +x Xilinx_Unified_*.bin ./Xilinx_Unified_*.bin avec * correspond à la version de Vivado installée. Ensuite, il faut suivre les différentes instructions sur l’interface graphique de l’utilitaire et donner le chemin vers le répertoire d’installation. L’ensemble de l’installation peut prendre plus d’une heure selon la connexion internet (téléchargement + installation).\n   Chaîne de compilation RISC-V RISC-V est le nom d’une architecture de jeu d’instructions libre et ouverte. Tous les processeurs disponibles dans HerdWare s’appuyent (entièrement ou partiellement) sur ses différentes spécifications.\nLa chaîne de compilation officielle est disponible GitHub. Elle permet la compilation et l’installation des différents outils pour la compilation de C/C++, l’édition des liens, le désassemblage etc.\nPour installer localement les différents outils: Ubuntu 20.04  git clone https://github.com/riscv/riscv-gnu-toolchain sudo apt-get install autoconf automake autotools-dev curl python3 libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev ninja-build ./configure --prefix=${RISCV_DIR} --with-arch=rv32ima --with-abi=ilp32 make     avec RISCV_DIR une variable contenant le chemin vers le répertoire où sera installée la chaîne de compilation. Il est possible de remplacer ${RISCV_DIR} directement par le chemin du répertoire.\n Remarque Il est possible d’effectuer une installation avec différentes options en suivant les instructions officielles. Il est également possible d’indiquer des options directement lors de la compilation. Les options -march et -mabi permettent notamment de changer l’architecture (les différentes extensions utilisées) et l’ABI. Actuellement, seule la version 32 bits de l’ISA RISC-V avec les extensions M et A (-march=rv32ima) et l’ABI la plus simple (-mabi=ilp32) a été testée.\n  Installation locale Finalement, une fois les différents outils nécessaires installés, il est possible d’utiliser librement le projet HerdWare. Pour l’installer, il est nécessaire d’utiliser git:\nUbuntu 20.04  git clone https://github.com/herd-ware/root herd-ware cd herd-ware git submodule update --init --recursive ./update.sh     HerdWare est divisé en plusieurs sous-modules git. Chaque composant principal (processeur, logiciel, outil etc.) dispose de son propre projet git et constitute une sous-partie du projet global. Cependant, à cause des différentes dépendances, un répertoire principal est nécessaire pour connecter l’ensemble. Le projet principal est celui nommé root. Il est organisé ainsi:\n fpga/: contient les fichiers nécessaires aux implémentations sur FPGA. hw/: contient les codes pour les composants matériels. sim/: contient les informations générées durant la simulation. Il est généré par le Makefile. sw/: contient les différents logiciels exécutables. build.sbt: est le fichier de configuration de sbt. Il indique notamment les dépendances entre les différents projets pour la conception matérielle. Makefile: met en place différentes commandes pour la génération du matériel ou la simulation.  ",
    "description": "",
    "tags": null,
    "title": "Installation",
    "uri": "/all/install/index.html"
  },
  {
    "content": "  Catégorie Nom Address   BOOT Début 0x00000000  Fin 0x03ffffff  ROM Début 0x04000000  Fin 0x07ffffff  RAM Début 0x08000000  Fin 0x0cffffff  I/Os (processeur) Début 0x10000000  Fin 0x17ffffff  I/Os (plateforme) Début 0x18000000  Fin 0x1fffffff   ",
    "description": "",
    "tags": null,
    "title": "Cartographie mémoire",
    "uri": "/doc/hw/pltf/cheese/mem/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Documentation",
    "uri": "/doc/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Interruptions locales du processeur (CLINT)",
    "uri": "/doc/hw/cores/aubrac/mem-hier/clint/index.html"
  },
  {
    "content": " Modules et interfaces communs Memory Bus for Security (MB4S) Processeurs Aubrac Salers Abondance I/Os GPIO UART Mémoires Mémoire cache Hay Plateformes Cheese  ",
    "description": "",
    "tags": null,
    "title": "Matériel",
    "uri": "/doc/hw/index.html"
  },
  {
    "content": "Vue globale   \nFigure 1: Vue globale du processeur Aubrac.  Tous les différents étages possibles sont représentés, même si certains d'entre eux sont optionnels.    ",
    "description": "",
    "tags": null,
    "title": "Processeur",
    "uri": "/doc/hw/cores/aubrac/top/core/index.html"
  },
  {
    "content": "Sommaire Aubrac Front-end Prédiction de branchement Back-end Hiérarchie mémoire Top Salers  Abondance Top  Résumé    Processeur Abréviation Version     Aubrac AU 0.0.1   Abondance AB 0.0.1   Salers SA     ",
    "description": "",
    "tags": null,
    "title": "Processeurs",
    "uri": "/doc/hw/cores/index.html"
  },
  {
    "content": "Sommaire Prédicteur de prochaine ligne (NLP)   Principes Pour anticiper les aléas du flot de contrôle, le processeur Aubrac met en place des mécanismes de prédiction de branchement. Le principe est de sauvegarder des informations au cours de l’exécution afin d’anticiper les futurs branchements ou sauts.\nDifférentes implémentations de prédicteurs sont possibles. Elles varient généralement par leur complexité et leur efficacité.\nImplémentations Actuellement, le processeur Aubrac dispose comme prédicteur de branchement:\n d’un NLP qui est la version la plus simpliste d’un prédicteur de branchement.  ",
    "description": "",
    "tags": null,
    "title": "Prédiction de branchement",
    "uri": "/doc/hw/cores/aubrac/pred/index.html"
  },
  {
    "content": "  Origine du nom Source de l'image.  Salers est le nom d’une race française de vaches originaire du Cantal dans le centre de la France. Elle est notamment élevée pour son lait utilisé pour le fromage Salers.\n  Cette page et les suivantes décrivent le processeur Salers. Il permet l’exécution dans l’ordre de plusieurs instructions par cycle. Il est conçu autour d’un pipeline et de deux niveaux de mémoires caches. Basé sur l’ISA RISC-V, il est développé en Chisel3 et se veut hautement configurable (taille des données, nombre d’étages, extensions du jeu d’instructions supportées etc.).\n Avertissement Une version précédente de Salers a servi de base pour certains travaux sur l’isolation microarchitecturale [Esco2021]. Elle supportait notamment plusieurs fils d’exécutions simultanés (multithreading). En théorie, si la partie Back-End permet toujours le support de plusieurs harts, la version globale actuelle a été simplifiée et ne permet plus qu’un fil d’exécution.\n  Vue globale Support du jeu d’instructions    Extension Version Implementée ? Testée ? Optionnelle ? Dépendances     M 2.0       A 2.1       B 1.0.0       Zicsr        Zicntr        Zifencei 2.0        Tableau 1: Résumé des différentes extensions RISC-V supportées par le processeur Salers.  Certaines doivent encore être testées plus en profondeur.     Avertissement Si les versions 32 et 64 bits sont implémentées, seule la version 32 bits est actuellement utilisée et testée. Un travail supplémentaire est nécessaire pour vérifier les instructions spécifiques à la version 64 bits, comme celles dédiées à la manipulation de mots de 32 bits.\n  Sommaire  ",
    "description": "",
    "tags": null,
    "title": "Salers",
    "uri": "/doc/hw/cores/salers/index.html"
  },
  {
    "content": "Protocole Transmetteur (Tx) Récepteur (Rx) Top ",
    "description": "",
    "tags": null,
    "title": "UART",
    "uri": "/doc/hw/io/uart/index.html"
  },
  {
    "content": "Unités d’exécution Unité arithmétique et logique (ALU) Unité de branchement (BRU) Unité de multiplication et division (MULDIV) ",
    "description": "",
    "tags": null,
    "title": "Étage EX{0-2}",
    "uri": "/doc/hw/cores/aubrac/back/ex/index.html"
  },
  {
    "content": "Fonctionnement À partir de l’adresse reçue depuis l’étage PC, les étages IF{0-2} sont responsables des requêtes vers la mémoire.\nL’étage IF0 émet la requête vers la mémoire. L’étage IF1 est optionnel: il permet de rajouter un cycle supplémentaire entre IF0 et IF2. Cela peut s’avérer nécessaire une mémoire cache est implémentée, afin de synchroniser les différents éléments. Enfin, l’étage IF2 gère la réception des instructions depuis la mémoire. Cet étage est également optionnel, avec des registres de sorties pouvant être implémentés ou non. Finalement, une instruction peut mettre entre deux et quatre cycles entre l’étage PC jusqu’à son enregistrement dans le fetch buffer.\nSi une opération nécessite un nettoyage du pipeline (e.g un flush) alors que la requête a déjà été envoyée, un signal abort permet de propager l’information. Dès que la réponse sera reçue depuis la mémoire, l’instruction sera alors annulée.\nL’interface mémoire est basée le bus MB4S.\n",
    "description": "",
    "tags": null,
    "title": "Étages IF{0-2}",
    "uri": "/doc/hw/cores/aubrac/front/if0_2/index.html"
  },
  {
    "content": "  Avertissement Avant de simuler un composant matériel, assurez-vous que les différents outils nécessaires soient installés comme expliqué sur la page dédiée. Notamment, les outils suivants sont utilisés:\n sbt, Verilator, GTKWave, la chaîne de compilation RISC-V.    Première simulation Pour effectuer une simulation, ouvrez un terminal et placez-vous dans le répertoire HerdWare installé précédemment:\n cd herd-ware Un fichier Makefile est disponible dans le répertoire principal root. Différentes commandes pour la génération et la simulation du matériel y sont définies. Dans cet exemple, l’objectif est de simuler une version de la plateforme Cheese. L’ISA et la configuration matérielle sont précisées dans le Makefile avec les variables ISA_CFG et HW_CFG.\n make cheese-sim ISA_CFG=P32 HW_CFG=AU1V000 Cette commande lance la génération dela plateforme Cheese en utilisation l’ISA P32 et la configuration matérielle AU1V000. Le répertoire sim/ est créé avec différents sous-dossiers. L’exécutable pour la simulation est disponible dans le répertoire sim/exe/. Ici, il se nomme HERD_P32_CHAU1V000.\nFinalement, pour lancer une simulation et générer un chronogramme, il faut suivre la commande suivante\n./sim/exe/HERD_P32_CHAU1V000 --boot BOOT_HEX_FILE --trigger N_TRIGGER --vcd VCD_FILE avec BOOT_HEX_FILE le contenu de la mémoire de démarrage BOOT dans un fichier au format hexadécimal, N_TRIGGER le nombre maximal de cycles d’exécution et VCD_FILE le fichier .vcd décrivant l’évolution des signaux. Voici un exemple de simulatio utilisant un program de test dans le répertoire isa-tests:\ncd sw/isa-tests make -f Makefile.riscv all cd ../.. ./sim/exe/HERD_P32_CHAU1V000 --boot sw/isa-tests/hex/riscv32-base-i-add.boot8.hex --trigger 1000 --vcd sim/vcd/HERD_P32_CHAU1V000/example.vcd Ensuite, l’évolution de l’exécution du test add peut être visualisée avec GTKWave:\ngtkwave sim/vcd/HERD_P32_CHAU1V000/example.vcd   Remarque Plus d’informations sur le processus de génération et la possibilité de concevoir des composants matériels précis sont disponibles sur la page dédiée.\n  Options de simulation    Option Valeur Description     –boot BOOT_HEX_FILE Obligatoire. Initialise le contenu de la mémoire de démarrage BOOT avec le fichier BOOT_HEX_FILE. BOOT_HEX_FILE doit contenir des valeurs hexadécimales, les octets étant séparés par des espaces.   –rom ROM_HEX_FILE Initialise le contenu de la mémoire ROM avec le fichier ROM_HEX_FILE. ROM_HEX_FILE doit contenir des valeurs hexadécimales, les octets étant séparés par des espaces.   –trigger N_TRIGGER Active un trigger pour stopper l’exécution après N_TRIGGER cycles.   –uart-cycle UART_CYCLE Nombre de cycles par bit utilisé par l’UART hôte.   –uart-in UART_IN_FILE Active l’envoi de données par l’UART hôte. Le fichier UART_IN_FILE conteint des valeurs hexadécimal, les octets étant séparés par des espaces.   –uart-out  Active l’affichage de chaque octet reçu par l’UART hôte.   –vcd VCD_FILE Active la génération d’un fichier VCD_FILE au format .vcd. Ce fichier décrit l’évolution de chaque signal du système durant l’exécution.   –etd ETD_FILE Active la génération d’un fichier ETD_FILE au format .etd. Ce fichier donne des informations sur chaque instruction complètement exécutée.   –hpc  Affiche la valeur des HPC pour chaque processeur à la fin de la simulation.    Tableau 1: Récapitulatif des différentes options de simulation     Chaque exécutable généré dans HerdWare pour la simulation supporte différentes options implémentées à l’aide de C++. Elles sont regroupées dans le Tableau 1. Dans le cas de la plateforme Cheese, le fichier top est disponible dans le répertoire suivant.\nExemples Les différentes options mises à disposition permettent différentes utilisations des exécutables. Cela peut aller d’un simple test à l’extraction d’informations durant une exécution. Ci-dessous sont décrits plusieurs scénarios possibles d’utilisation.\nSimulation standard Traces d’exécution HPC ",
    "description": "",
    "tags": null,
    "title": "Simulation",
    "uri": "/all/sim/index.html"
  },
  {
    "content": "  Origine du nom Source de l'image.  Abondance est le nom d’une race française de vaches originaire de Haute-Savoie dans le sud-est de la France. Elle est principalement élevée pour son lait utilisée dans différents fromages comme le Reblochon, l’Abondance et bien d’autres.\n  Cette page et les suivantes décrivent le processeur Abondance. Il permet l’exécution dans le désordre de plusieurs instructions par cycle. Il est conçu autour d’un pipeline et plusieurs unités, ainsi que deux niveaux de mémoires caches. Basé sur l’ISA RISC-V, il est développé en Chisel3 et se veut hautement configurable (taille des données, nombre d’étages, extensions du jeu d’instructions supportées etc.).\nVue globale   \nFigure 1: Vue globale du processeur Abondance.  Tous les différents étages et unités possibles sont représentés, même si certains d'entre eux sont optionnels.    La Figure 1 représente le processeur Abondance dans son ensemble. Is est composé de 10 parties. Le Front-End est responsable de la récupération des instructions en mémoire. Le NLP est responsable de la prédiction des aléas du flot de contrôle. Le Back-End est responsable du décodage et de la gestion des exécutions. Il intègre aussi les mécanismes de renommage pour les registres d’entiers utilisés par plusieurs unités. L’unité INT est responsable de l’exécution des opérations sur les entiers. L’unité LSU est responsable de l’exécution des opérations mémoires sur les entiers. L’unité de gestion des champs matériels (HFU) est une unité d’exécution dédiée à la contextualisation (CHAMP ISA). Le module des I/O est utilisé pour les mécanismes addressables en mémoire spécifiques au processeur (e.g. les timers privilégiés). Enfin, L1I, L1D et L2 sont respectivement le cache d’instruction de niveau 1, le cache de données de niveau 1 et le cache unifié de niveau 2.\nSupport du jeu d’instructions Le processeur Abondance est basé sur l’ISA RISC-V. Il supporte actuellement les bases 32 et 64 bits du jeu d’instructions.\n   Extension Version Implementée ? Testée ? Optionnelle ? Dépendances     M 2.0       A 2.1       B 1.0.0       Zicsr        Zicntr        Zifencei 2.0        Tableau 1: Résumé des différentes extensions RISC-V supportées par le processeur Abondance.  Certaines doivent encore être testées plus en profondeur.    Comme décrit dans la Tableau 1, de multiples extensions sont actuellemnt implémentées dans Abondance. La plupart d’entre elles sont optionnelles: les différents mécanismes matériels dédiés peuvent être totalement supprimés lors de la génération du Verilog.\n Avertissement Si les versions 32 et 64 bits sont implémentées, seule la version 32 bits est actuellement utilisée et testée. Un travail supplémentaire est nécessaire pour vérifier les instructions spécifiques à la version 64 bits, comme celles dédiées à la manipulation de mots de 32 bits.\n  Sommaire Top   ",
    "description": "",
    "tags": null,
    "title": "Abondance",
    "uri": "/doc/hw/cores/abondance/index.html"
  },
  {
    "content": "Sommaire Étage ID  Étage EX{0-2}  Étage MEM  Étage WB  Registres généraux (GPR)  Registres de Contrôle et de Statut (CSR)   ",
    "description": "",
    "tags": null,
    "title": "Back-end",
    "uri": "/doc/hw/cores/aubrac/back/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "I/Os",
    "uri": "/doc/hw/io/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "ISA tests",
    "uri": "/doc/sw/isa-tests/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Logiciel",
    "uri": "/doc/sw/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Mémoires",
    "uri": "/doc/hw/mem/index.html"
  },
  {
    "content": "Exemple Chisel3 // ****************************** // AUBRAC CORE CONFIG // ****************************** object AubracConfigBase extends AubracConfig (  // ------------------------------  // GLOBAL  // ------------------------------  debug = true, // Boolean -\u003e Active les signaux/registres de débuggage en simulation.  pcBoot = \"00001000\", // String -\u003e Adresse de démarrage  nAddrBit = 32, // Int -\u003e Taille d'une addresse (en bit)  nDataBit = 32, // Int -\u003e Taille d'une donnée (en bit)   // ------------------------------  // CHAMP  // ------------------------------  useChamp = true, // Boolean -\u003e Ative l'utilisation de l'ISA CHAMP.  nChampReg = 4, // Int -\u003e Nombre de registres CHAMP.  useChampExtMie = true, // Boolean -\u003e Active l'isolation microarchitecturale des exécutions (mie)  useChampExtFr = false, // Boolean -\u003e (Non-utilisé).  useChampExtCst = true, // Boolean -\u003e Active les flushs en temps constant.  nChampTrapLvl = 2, // Boolean -\u003e Niveaux de traps   nPart = 2, // Int -\u003e Nombre de parties matérielles.  nFieldFlushCycle = 10, // Int -\u003e Nombre de cycles par flush (pour temps constant).   // ------------------------------  // FRONT END  // ------------------------------  nFetchInstr = 1, // Int -\u003e Nombres d'instructions récupérées simultanément  useIMemSeq = true, // Boolean -\u003e Accès mémoire séquentiel  useIf1Stage = false, // Boolean -\u003e Active le stage IF1  nFetchBufferDepth = 2, // Int -\u003e Taille du fetch buffer   // ------------------------------  // NEXT-LINE PREDICTOR  // ------------------------------  useNlp = true, // Boolean -\u003e Utilise le NLP  nBtbLine = 8, // Int -\u003e Taille du BTB  nBhtSet = 8, // Int -\u003e Nombre d'ensembles du BHT  nBhtSetEntry = 128, // Int -\u003e Nombre d'entrées par ensemble du BHT  nBhtBit = 2, // Int -\u003e Nombre de bits par compteur du BHT  useRsbSpec = true, // Boolean -\u003e Active ls RSB spéculatif  nRsbDepth = 8, // Int -\u003e Taille du RSB   // ------------------------------  // BACK END  // ------------------------------  useExtM = true, // Boolean -\u003e  useExtA = false, // Boolean -\u003e  useExtB = false, // Boolean -\u003e  useExtZifencei = true, // Boolean -\u003e  useExtZicbo = true, // Boolean -\u003e  nExStage = 1,  useMemStage = true, // Boolean -\u003e  useBranchReg = true, // Boolean -\u003e   // ------------------------------  // I/Os  // ------------------------------  nIOAddrBase = \"00100000\",  nScratch = 2,  nCTimer = 2,  isHpmAct = Array(\"ALL\"),  hasHpmMap = Array(),   nUnCacheBase = \"70000000\", // Int -\u003e  nUnCacheByte = \"01000000\",   // ------------------------------  // L1I CACHE  // ------------------------------  useL1I = true,  nL1INextDataByte = 8,  nL1INextLatency = 1,   useL1IPftch = false,  nL1IPftchEntry = 4,  nL1IPftchEntryAcc = 1,  nL1IPftchMemRead = 1,  nL1IPftchMemWrite = 1,   nL1IMem = 1,  nL1IMemReadPort = 2,  nL1IMemWritePort = 1,   slctL1IPolicy = \"BitPLRU\",  nL1ISet = 4,  nL1ILine = 4,  nL1IData = 4,   // ------------------------------  // L1D CACHE  // ------------------------------  useL1D = true,  nL1DNextDataByte = 8,  nL1DNextLatency = 1,   useL1DPftch = false,  nL1DPftchEntry = 4,  nL1DPftchEntryAcc = 1,  nL1DPftchMemRead = 1,  nL1DPftchMemWrite = 1,   nL1DMem = 1,  nL1DMemReadPort = 2,  nL1DMemWritePort = 1,   slctL1DPolicy = \"BitPLRU\",  nL1DSet = 4,  nL1DLine = 4,  nL1DData = 4,   // ------------------------------  // L2 CACHE  // ------------------------------  useL2 = true,  nL2NextDataByte = 8,  useL2ReqReg = true,  useL2AccReg = false,  useL2AckReg = false,  nL2WriteFifoDepth = 2,  nL2NextFifoDepth = 2,  nL2NextLatency = 1,   useL2Pftch = false,  nL2PftchEntry = 4,  nL2PftchEntryAcc = 1,  nL2PftchMemRead = 1,  nL2PftchMemWrite = 1,   nL2Mem = 2,  nL2MemReadPort = 2,  nL2MemWritePort = 1,   slctL2Policy = \"BitPLRU\",  nL2Set = 4,  nL2Line = 4,  nL2Data = 4 ) ",
    "description": "",
    "tags": null,
    "title": "Paramètres",
    "uri": "/doc/hw/cores/aubrac/top/params/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Timers privilégiés",
    "uri": "/doc/hw/cores/aubrac/mem-hier/timers/index.html"
  },
  {
    "content": "Vue globale ",
    "description": "",
    "tags": null,
    "title": "Étage IF3",
    "uri": "/doc/hw/cores/aubrac/front/if3/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Étage MEM",
    "uri": "/doc/hw/cores/aubrac/back/mem/index.html"
  },
  {
    "content": "  Avertissement Avant de simuler un composant matériel, assurez-vous que les différents outils nécessaires soient installés comme expliqué sur la page dédiée. Notamment, les outils suivants sont utilisés:\n sbt, Vivado    ",
    "description": "",
    "tags": null,
    "title": "FPGA",
    "uri": "/all/fpga/index.html"
  },
  {
    "content": "Sommaire Mémoires caches  Interruptions locales du processeur (CLINT)  Timers privilégiés  Moniteur des performances matérielles (HPM)   ",
    "description": "",
    "tags": null,
    "title": "Hiérarchie mémoire",
    "uri": "/doc/hw/cores/aubrac/mem-hier/index.html"
  },
  {
    "content": "Récapitulatif    Nom Description     alu Instructions de type ALU exécutées.   bru Instructions de type BRU exécutées.   cycle Cycles depuis le dernier reset global.   instret Instructions exécutées.   l1ihit Accès au L1I étant un hit.   l1ipftch Accès au L1I anticipé par le prefetcher.   l1imiss Accès au L1I étant un miss.   l1dhit Accès au L1D étant un hit.   l1dpftch Accès au L1D anticipé par le prefetcher.   l1dmiss Accès au L1D étant un miss.   l2hit Accès au L2 étant un hit.   l2pftch Accès au L2 anticipé par le prefetcher.   l2miss Accès au L2 étant un miss.   ld Instructions load exécutées.   mispred Instructions de type BRU exécutées mais mal prédites.   rdcycle Instructions rdcycle exécutées.   st Instructions store exécutées.   time Cycles depuis le dernier reset global.    Tableau 1: Description des différents compteurs de performance.     ",
    "description": "",
    "tags": null,
    "title": "Moniteur des performances matérielles (HPM)",
    "uri": "/doc/hw/cores/aubrac/mem-hier/hpm/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Étage WB",
    "uri": "/doc/hw/cores/aubrac/back/wb/index.html"
  },
  {
    "content": "  Avertissement Avant de générer un composant matériel, assurez-vous que les différents outils nécessaires soient installés comme expliqué sur la page dédiée. Notamment, les outils suivants sont utilisés:\n sbt, Verilator    Générer un composant matériel Il est possible de générer le Verilog de chaque composant matériel du projet. Tout d’abord, vous devez localiser dans quelle librairie se trouve la class et l’object correspondants. Par exemple, le composant Example est situé dans le fichier example.scala Le fichier est placé dans la librairie herd.draft.example. L’object permettant la génération du Verilog est le suivant:\nobject Example extends App {  (new chisel3.stage.ChiselStage).emitVerilog(new Example(4), args) } Ainsi, pour générer le Verilog correspondant, il faut se placer à la base du projet root et lancer la commande:\nsbt \"runMain herd.draft.example.Example --target-dir output\" --target-dir output indique le répertoire où seront générés les fichiers. Finalement, le fichier output/Example.v a été créé.\nCréer une configuration de plateforme Différentes configurations de plaateformes sont disponibles. Elles utilisents différentes variantes de processeurs, de jeux d’instructions, de périphériques etc. Pour certains usages, il peut être intéressant d’en créeer une s’daptant à des besoins spécifiques.\nNous allons prendre ici le cas de la plateforme Cheese. Ses différentes configurations sont placée dans le répertoire src/main/scala/configs/. Pour créer votre propre configuration, copiez le fichier P32AU1V000.scala et changez son nom. Ensuite, dans le fichier lui-même, remplacez également les différentes apparitions du nom d’origine (*e.g. CheeseParamsP32AU1V000, CheeseConfigP32AU1V000). Ensuite, modifiez les différents paramètres de la plateforme selon vos besoins. Là encore, n’oubliez pas l’object permettant la génération du Verilog:\nobject CheeseP32AU1V000 extends App {  (new chisel3.stage.ChiselStage).emitVerilog(new Cheese(new CheeseConfigP32AU1V000(debug = false)), args) } Le paramètre debug est ici précisé directement au moment de la création de l’objet. Enfin, pour générer le Verilog correspondant, adaptez l’une des commandes suivantes avec le nom de votre configuration:\nsbt make  sbt \"runMain herd.pltf.cheese.CheeseP32AU1V000 --target-dir output\"   make cheese-build ISA_CFG=P32 HW_CFG=AU1V000      Nommage des configurations Considérons le design HERD_P32_CHAU1V000. La configuration correspondante de la plateforme Cheese est P32AU1V000. Ainsi, les différentes configurations sont actuellement nommées à partir de la convention suivante:\n P: l’ISA privilégiée utilisée, avec P pour l’ISA RISC-V privilégiée ou C pour l’ISA CHAMP ISA. 32: la taille des données, ici 32 bits. AU1: les processeurs implémentés et le nombre d’instances, ici 1 processeur Aubrac. V000: la version avec un nombre arbitraire pour différencier des spécificités matérielles internes.  Ensuite, les différentes instances utilisent le modèle HERD_${ISA}_${HW} avec ${ISA} et ${HW} respectivement les informations sur l’ISA et le matériel. Pour décrire le système final, d’autres indications sont ajoutées sur le projet et la plateforme. Le format HERD_${ISA}_${HW} est utilisé avec comme informations supplémentaires:\n HERD: le préfixe du projet, CH la plateforme matérielle, ici Cheese.    Créer un simulateur de plateforme Pour générer un exécutable pour la simulation, des étapes supplémentaires sont nécessaires. Tout d’abord, copiez et modifiez avec le nom de votre configuration l’un des fichiers dans le répertoire src/test/scala/configs/. Cela permettra d’instancier le composant correspondant au simulateur de la plateforme. Lors de la création de l’object, assurez-vous que debug = true pour conserver certains signaux de debuggage. Enfin, pour générer l’exécutable, adaptez la commande suivante:\nFinally, to generate the executable, adapt the following command:\nmake cheese-sim ISA_CFG=P32 HW_CFG=AU1V000 Support des tests unitaires Pour le support des tests unitaires, il est également nécessaire de copier et modifier un fichier de test dans hw/pltf/cheese/sim/isa-tests. Dans ces fichiers *.tst, le format est le suivant:\n 1ère colonne: nom du test. 2ème colonne: nombre attendu d’instructions exécutées. 3ème colonne: nombre attendu de cycles d’exécution.  Une nouvelle configuration doit aussi être ajoutée dans le fichier configs.h. Finalement, après la compilation des tests dans sw/isa-tests, il suffit de lancer:\nmake cheese-test ISA_CFG=P32 HW_CFG=AU1V000 Ajouter un composant matériel (draft) Ajouter un composant matériel (sous-module) Ajouter un test unitaire ",
    "description": "",
    "tags": null,
    "title": "Génération matérielle configurable",
    "uri": "/all/hw/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Plateformes",
    "uri": "/doc/hw/pltf/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Registres généraux (GPR)",
    "uri": "/doc/hw/cores/aubrac/back/gpr/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Top",
    "uri": "/doc/hw/cores/abondance/top/index.html"
  },
  {
    "content": "Sommaire Pipeline  Processeur  Paramètres   ",
    "description": "",
    "tags": null,
    "title": "Top",
    "uri": "/doc/hw/cores/aubrac/top/index.html"
  },
  {
    "content": "Récapitulatif    Nom Adresse (64/32 bits) Adresse (32 bits) Description     cycle 0xc00 0xc80 Cycles depuis le dernier reset global.   time 0xc01 0xc81 Cycles depuis le dernier reset global.   instret 0xc02 0xc82 Instructions exécutées.   hpmcounter3 0xc03 0xc83 Compteur de performances 3.   hpmcounter4 0xc04 0xc84 Compteur de performances 4.   hpmcounter5 0xc05 0xc85 Compteur de performances 5.   hpmcounter6 0xc06 0xc86 Compteur de performances 6.   hpmcounter7 0xc07 0xc87 Compteur de performances 7.   hpmcounter8 0xc08 0xc88 Compteur de performances 8.   hpmcounter9 0xc09 0xc89 Compteur de performances 9.   hpmcounter10 0xc0a 0xc8a Compteur de performances 10.   hpmcounter11 0xc0b 0xc8b Compteur de performances 11.   hpmcounter12 0xc0c 0xc8c Compteur de performances 12.   hpmcounter13 0xc0d 0xc8d Compteur de performances 13.   hpmcounter14 0xc0e 0xc8e Compteur de performances 14.   hpmcounter15 0xc0f 0xc8f Compteur de performances 15.   hpmcounter16 0xc10 0xc90 Compteur de performances 16.   hpmcounter17 0xc11 0xc91 Compteur de performances 17.   hpmcounter18 0xc12 0xc92 Compteur de performances 18.   hpmcounter19 0xc13 0xc93 Compteur de performances 19.   hpmcounter20 0xc14 0xc94 Compteur de performances 20.   hpmcounter21 0xc15 0xc95 Compteur de performances 21.   hpmcounter22 0xc16 0xc96 Compteur de performances 22.   hpmcounter23 0xc17 0xc97 Compteur de performances 23.   hpmcounter24 0xc18 0xc98 Compteur de performances 24.   hpmcounter25 0xc19 0xc99 Compteur de performances 25.   hpmcounter26 0xc1a 0xc9a Compteur de performances 26.   hpmcounter27 0xc1b 0xc9b Compteur de performances 27.   hpmcounter28 0xc1c 0xc9c Compteur de performances 28.   hpmcounter29 0xc1d 0xc9d Compteur de performances 29.   hpmcounter30 0xc1e 0xc9e Compteur de performances 30.   hpmcounter31 0xc1f 0xc9f Compteur de performances 31.    Tableau 1: Description des différents CSR communs aux différentes ISA  Pour les implémentations 64 bits, une seule instruction permet de lire l'intégralité de chaque registre. Dans le cas des implémentations 32 bits, une lecture supplémentaire est nécessaire pour lire les 32 bits de poids fort.    ",
    "description": "",
    "tags": null,
    "title": "Registres de Contrôle et de Statut (CSR)",
    "uri": "/doc/hw/cores/aubrac/back/csr/index.html"
  },
  {
    "content": "  Remarque Tous les tags des versions du projet disponibles sur GitHub ont le suffixe *-public. Cela permet de les distinguer des versions propres aux travaux de recherche en cours et pas encore publiés.\n  v0.0.2 - 2023-04-22  Ajout du processeur superscalaire Salers grandement basé sur les modules du processeur Aubrac. Ajout d’une librairie logicielle lib-herd pour la définition de fonctions et structures communes à l’ensemble des systèmes. Ajout d’un répertoire logiciel bare décrivant un programme bare-metal minimaliste. Uniformisation des codes des différents processeurs (Aubrac, Salers et Abondance) dans le but de faciliter la compréhension. Dans ce sens, le noms de certains signaux et modules ont été modifiés. Ajout de nouveaux HPC et CSR. Les implémentations ont été modifiées pour permettre une meilleure configuration et faciliter de futurs ajouts. Mise à disposition des codes sur GitHub:  Common (v0.0.2), Aubrac (v0.0.2), Salers (v0.0.1), Abondance (v0.0.2), Hay (v0.0.2), I/Os (v0.0.2), Cheese (v0.0.2), ISA tests (v0.0.2), HERD Library (v0.0.1), Bare-metal software (v0.0.1), répertoire root (v0.0.2).    v0.0.1 - 2023-03-30  Documentation publique sur GitHub. Mise à disposition des codes sur GitHub:  Common (v0.0.1), Aubrac (v0.0.1), Abondance (v0.0.1), Hay (v0.0.1), I/Os (v0.0.1), Cheese (v0.0.1), ISA tests (v0.0.1), répertoire root (v0.0.1).    ",
    "description": "",
    "tags": null,
    "title": "Historique",
    "uri": "/all/history/index.html"
  },
  {
    "content": "Vue globale Modèle Chisel object FrontConfigBase extends FrontConfig (  debug = true, // Boolean -\u003e Active les signaux/registres de débuggage en simulation.  pcBoot = \"00001000\", // String -\u003e Adresse de démarrage  nHart = 1, // Int -\u003e Nombre de harts   useField = false, // Int -\u003e Active l'utilisation des champs matériels  nField = 1, // Int -\u003e Nombre de champs matériels  nPart = 1, // Int -\u003e Nombre de parties matérielless   nAddrBit = 32, // Int -\u003e Taille d'une adresse (en bit)  nInstrByte = 4, // Int -\u003e Taille maximale d'une instruction (en octet)  nFetchInstr = 2, // Int -\u003e Nombres d'instructions récupérées simultanément   useIMemSeq = false, // Boolean -\u003e Accès mémoire séquentiel  useIf1Stage = true, // Boolean -\u003e Active le stage IF1  useIf2Stage = true, // Boolean -\u003e Active le stage IF2  nFetchBufferDepth = 4, // Int -\u003e Taille du fetch buffer  useNlp = true, // Boolean -\u003e Utilise le NLP  useFastJal = true, // Boolean -\u003e Active pré-décodage du jal   nBackPort = 1 // Int -\u003e Nombres d'instructions lues simultanément ) ",
    "description": "",
    "tags": null,
    "title": "Paramètres",
    "uri": "/doc/hw/cores/aubrac/front/params/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Publications",
    "uri": "/more/publi/index.html"
  },
  {
    "content": "Sommaire  Sommaire Conception de systèmes numériques et outils Architecture de jeu d’instructions Microarchitecture des processeurs Isolation de la microarchitecture Canaux auxiliaires  Conception de systèmes numériques et outils [Chisel]: Chisel/FIRRTL Hardware Compiler Framework   2023   Notes:   [Verilator]: Verilator  Snyder, Wilson 2022   Notes:   Architecture de jeu d’instructions [Patt2017]: Computer Organization and Design RISC-V Edition: The Hardware Software Interface  Patterson, David A. and Hennessy, John L. Avril 2017   Notes:   [Wate2019]: The RISC-V Instruction Set Manual Volume I: Unprivileged ISA  Waterman, Andrew and Asanovic, Krste Décembre 2019   Notes:   [Wate2021]: The RISC-V Instruction Set Manual Volume II: Privileged Architecture  Waterman, Andrew and Asanovic, Krste Décembre 2021   Notes:   Microarchitecture des processeurs [Henn2011]: Computer Architecture: A Quantitative Approach  Hennessy, John L. and Patterson, David A. Septembre 2011   Notes:   Isolation de la microarchitecture [Ge2018a]: No Security Without Time Protection: We Need a New Hardware-Software Contract  Ge, Qian and Yarom, Yuval and Heiser, Gernot 9th Asia-Pacific Workshop on Systems (APSys'18), 2018   Notes:   [Koch2019]: Spectre Attacks: Exploiting Speculative Execution  Kocher, Paul and Horn, Jann and Fogh, Anders and Genkin, Daniel and Gruss, Daniel and Haas, Werner and Hamburg, Mike and Lipp, Moritz and Mangard, Stefan and Prescher, Thomas and Schwarz, Michael and Yarom, Yuval 40th IEEE Symposium on Security and Privacy (S\u0026P'19), Mai 2019   Notes:   [Lipp2018]: Meltdown: Reading Kernel Memory from User Space  Lipp, Moritz and Schwarz, Michael and Gruss, Daniel and Prescher, Thomas and Haas, Werner and Fogh, Anders and Horn, Jann and Mangard, Stefan and Kocher, Paul and Genkin, Daniel and Yarom, Yuval and Hamburg, Mike 27th USENIX Security Symposium (USENIX Security'18), Août 2018   Notes:   [Van2018]: Foreshadow: Extracting the Keys to the Intel SGX Kingdom with Transient out-of-Order Execution  Van Bulck, Jo and Minkin, Marina and Weisse, Ofir and Genkin, Daniel and Kasikci, Baris and Piessens, Frank and Silberstein, Mark and Wenisch, Thomas F. and Yarom, Yuval and Strackx, Raoul 27th USENIX Security Symposium (USENIX Security'18), Août 2018   Notes:   [Weis2018]: Foreshadow-NG: Breaking the Virtual Memory Abstraction with Transient out-of-Order Execution  Weisse, Ofir and Van Bulck, Jo and Minkin, Marina and Genkin, Daniel and Kasikci, Baris and Piessens, Frank and Silberstein, Mark and Strackx, Raoul and Wenisch, Thomas F. and Yarom, Yuval 2018   Notes:   Canaux auxiliaires [Mars2021a]: MIRACLE: MIcRo-ArChitectural Leakage Evaluation: A Study of Micro-Architectural Power Leakage across Many Devices  Marshall, Ben and Page, Dan and Webb, James Novembre 2021   Notes:   ",
    "description": "",
    "tags": null,
    "title": "Références",
    "uri": "/refs/index.html"
  },
  {
    "content": "Contributeurs  Mathieu Escouteloup  Contact En cas de question ou commentaire à propos du projet, des designs ou des développements actuels, n’hésitez pas à envoyer un email. En cas de problème technique précis, il est également possible de créer une issue dédiée sur le projet GitHub correspondant (e.g. page d’issue pour root).\n",
    "description": "",
    "tags": null,
    "title": "À propos",
    "uri": "/more/about/index.html"
  },
  {
    "content": " BHT: Branch History Table  Définition:   BTB: Branch Target Buffer  Définition:   EDA: Electronic Design Automation  Définition:   HDL: Langage de description matérielle (ou \"Hardware Description Language\" en anglais)  Définition:   ISA: Architecture de jeu d'instructions (ou \"Instruction Set Architecture\" en anglais)  Définition:   NLP: Prédicteur de prochaine ligne (ou \"Next Line Predictor\" en anglais)  Définition:   RAS: Return Address Stack  Définition:   Voir aussi:  RSB  RSB: Return Stack Buffer  Définition:   Voir aussi:  RAS  ",
    "description": "",
    "tags": null,
    "title": "Glossaire",
    "uri": "/gls/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "content": "",
    "description": "",
    "tags": null,
    "title": "Tags",
    "uri": "/tags/index.html"
  }
]
